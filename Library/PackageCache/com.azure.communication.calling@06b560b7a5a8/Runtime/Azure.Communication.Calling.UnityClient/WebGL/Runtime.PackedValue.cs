#if UNITY_WEBGL && !UNITY_EDITOR
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// ACSCallingShared
// This file was auto-generated from ACSCallingModelBETA.cs.
//

// <auto-generated />

namespace Azure.Communication.Calling.UnityClient
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit)]
    internal struct PackedValue
    {
        private readonly static int IntPtrSize = Marshal.SizeOf<IntPtr>();

        [FieldOffset(0)]
        public PackedValueType Type;

        [FieldOffset(4)]
        public int Size;

        [FieldOffset(8)]
        public IntPtr Pointer;

        [FieldOffset(8)]
        public UInt64 UInt64;

        [FieldOffset(8)]
        public Int64 Int64;

        public static string UnpackString(PackedValue packedValue)
        {
            if (packedValue.Pointer == IntPtr.Zero)
            {
                return null;
            }

            switch (packedValue.Type)
            {
                case PackedValueType.NarrowString:
                    return Marshal.PtrToStringAnsi(packedValue.Pointer, packedValue.Size);
                case PackedValueType.WideString:
                    return Marshal.PtrToStringUni(packedValue.Pointer, packedValue.Size);
                default:
                    throw new ArgumentException("UnpackString expects a 'NarrowString' or 'WideString' type.");
            }
        }

        public static IReadOnlyList<T> UnpackPtrs<T>(PackedValue packedValue, Func<IntPtr, T> factory, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));

            if (packedValue.Pointer == IntPtr.Zero || packedValue.Size <= 0)
            {
                return Array.Empty<T>();
            }

            List<T> result = new List<T>(packedValue.Size);
            for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * IntPtrSize); cursor += IntPtrSize)
            {
                IntPtr handle = Marshal.ReadIntPtr(cursor);

                result.Add(handle != IntPtr.Zero ? factory(handle) : default);
            }

            if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }

            return result;
        } 

        public static IReadOnlyList<T> UnpackStructs<T>(PackedValue packedValue, bool free = false) where T : struct
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));

            if (packedValue.Pointer == IntPtr.Zero || packedValue.Size <= 0)
            {
                return Array.Empty<T>();
            }

            List<T> result = new List<T>(packedValue.Size);
            int structureSize = Marshal.SizeOf<T>();
            for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * structureSize); cursor += structureSize)
            {
                T newStruct = Marshal.PtrToStructure<T>(cursor);
                result.Add(newStruct);
            }

            if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }

            return result;
        }

        public static byte[] UnpackBytes(PackedValue packedValue, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));

            if (packedValue.Pointer == IntPtr.Zero || packedValue.Size <= 0)
            {
                return Array.Empty<byte>();
            }

            byte[] result = new byte[packedValue.Size];
            Marshal.Copy(packedValue.Pointer, result, 0, packedValue.Size);
            if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }

            return result;
        }

        public static int[] UnpackIntegers(PackedValue packedValue, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));

            if (packedValue.Pointer == IntPtr.Zero || packedValue.Size <= 0)
            {
                return Array.Empty<int>();
            }

            int[] result = new int[packedValue.Size];
            Marshal.Copy(packedValue.Pointer, result, 0, packedValue.Size);
            if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }

            return result;
        }

    	public static string[] UnpackStrings(PackedValue packedValue, bool free = false)
        {
            if (packedValue.Pointer == IntPtr.Zero || packedValue.Size <= 0)
            {
                return Array.Empty<string>();
            }

            string[] result = new string[packedValue.Size];
            Func<IntPtr, string> marshaller;
            if (packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.NarrowString))
            {
                marshaller = Marshal.PtrToStringAnsi;
            }
            else if (packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.WideString))
            {
                marshaller = Marshal.PtrToStringUni;
            }
            else
            {
                throw new ArgumentException("UnpackListString expects a 'NarrowString' or 'WideString' type.");
            }

            int r = 0;
            for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * IntPtrSize); cursor += IntPtrSize)
            {
                IntPtr handle = Marshal.ReadIntPtr(cursor);
                if(handle != IntPtr.Zero) result[r++] = marshaller(handle);
                if (free) { Marshal.FreeCoTaskMem(handle); }
            }

            if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }

            return result;
        }

        public static implicit operator IntPtr(PackedValue packedValue) => packedValue.Type == PackedValueType.Pointer ? packedValue.Pointer : throw new InvalidCastException();

        public static implicit operator ulong(PackedValue packedValue) => packedValue.Type == PackedValueType.UInt64 ? packedValue.UInt64 : throw new InvalidCastException();

        public static implicit operator long(PackedValue packedValue) => packedValue.Type == PackedValueType.Int64 ? packedValue.Int64 : throw new InvalidCastException();
    }

}
#endif

