//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Microsoft.Azure.ObjectAnchors
// This file was auto-generated from AbiDefinition.cs.
//

// <auto-generated />

namespace Microsoft.Azure.ObjectAnchors
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit)]
    internal struct PackedValue
    {
        private readonly static int IntPtrSize = Marshal.SizeOf<IntPtr>();

        [FieldOffset(0)]
        public PackedValueType Type;

        [FieldOffset(4)]
        public int Size;

        [FieldOffset(8)]
        public IntPtr Pointer;

        [FieldOffset(8)]
        public UInt64 UInt64;

        [FieldOffset(8)]
        public Int64 Int64;

        public static string UnpackString(PackedValue packedValue)
        {
            if (packedValue.Pointer == IntPtr.Zero) { return null; }

            switch (packedValue.Type)
            {
                case PackedValueType.NarrowString:
                    return Marshal.PtrToStringAnsi(packedValue.Pointer, packedValue.Size);
                case PackedValueType.WideString:
                    return Marshal.PtrToStringUni(packedValue.Pointer, packedValue.Size);
                default:
                    throw new ArgumentException("UnpackString expects a 'NarrowString' or 'WideString' type.");
            }
        }

        public static List<T> UnpackPtrs<T>(PackedValue packedValue, Func<IntPtr, T> factory, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));
            List<T> result = null;

            if (packedValue.Pointer != IntPtr.Zero && packedValue.Size > 0)
            {
                result = new List<T>(packedValue.Size);
                for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * IntPtrSize); cursor += IntPtrSize)
                {
                    IntPtr handle = Marshal.ReadIntPtr(cursor);

                    result.Add(handle != IntPtr.Zero ? factory(handle) : default);
                }

                if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }
            }

            return result;
        } 

        public static List<T> UnpackStructs<T>(PackedValue packedValue, bool free = false) where T : struct
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));
            List<T> result = null;

            if (packedValue.Pointer != IntPtr.Zero && packedValue.Size > 0)
            {
                result = new List<T>(packedValue.Size);
                int structureSize = Marshal.SizeOf<T>();
                for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * structureSize); cursor += structureSize)
                {
                    T newStruct = Marshal.PtrToStructure<T>(cursor);
                    result.Add(newStruct);
                }

                if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }
            }

            return result;
        }

        public static byte[] UnpackBytes(PackedValue packedValue, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));
            byte[] result = null;
            if (packedValue.Pointer != IntPtr.Zero && packedValue.Size > 0)
            {
                result = new byte[packedValue.Size];
                Marshal.Copy(packedValue.Pointer, result, 0, packedValue.Size);
                if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }
            }
            return result;
        }

        public static int[] UnpackIntegers(PackedValue packedValue, bool free = false)
        {
            Debug.Assert(packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.Pointer));
            int[] result = null;
            if (packedValue.Pointer != IntPtr.Zero && packedValue.Size > 0)
            {
                result = new int[packedValue.Size];
                Marshal.Copy(packedValue.Pointer, result, 0, packedValue.Size);
                if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }
            }
            return result;
        }

    	public static string[] UnpackStrings(PackedValue packedValue, bool free = false)
        {
            string[] result = null;
            if (packedValue.Pointer != IntPtr.Zero && packedValue.Size > 0)
            {
                result = new string[packedValue.Size];
                Func<IntPtr, string> marshaller;
                if (packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.NarrowString))
                {
                    marshaller = Marshal.PtrToStringAnsi;
                }
                else if (packedValue.Type == (PackedValueType.SimpleArray | PackedValueType.WideString))
                {
                    marshaller = Marshal.PtrToStringUni;
                }
                else
                {
                    throw new ArgumentException("UnpackListString expects a 'NarrowString' or 'WideString' type.");
                }

                int r = 0;
                for (IntPtr cursor = packedValue.Pointer; cursor != packedValue.Pointer + (packedValue.Size * IntPtrSize); cursor += IntPtrSize)
                {
                    IntPtr handle = Marshal.ReadIntPtr(cursor);
                    if(handle != IntPtr.Zero) result[r++] = marshaller(handle);
                    if (free) { Marshal.FreeCoTaskMem(handle); }
                }

                if (free) { Marshal.FreeCoTaskMem(packedValue.Pointer); }
            }

            return result;
        }

        public static implicit operator IntPtr(PackedValue packedValue) => packedValue.Type == PackedValueType.Pointer ? packedValue.Pointer : throw new InvalidCastException();

        public static implicit operator ulong(PackedValue packedValue) => packedValue.Type == PackedValueType.UInt64 ? packedValue.UInt64 : throw new InvalidCastException();

        public static implicit operator long(PackedValue packedValue) => packedValue.Type == PackedValueType.Int64 ? packedValue.Int64 : throw new InvalidCastException();
    }

}

