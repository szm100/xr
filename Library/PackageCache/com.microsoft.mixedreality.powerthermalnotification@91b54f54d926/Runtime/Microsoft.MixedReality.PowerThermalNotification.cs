#if UNITY_WSA && !UNITY_EDITOR
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Microsoft.MixedReality.PowerThermalNotification
// This file was auto-generated from AbiDefinition.cs.
//

// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.MixedReality.PowerThermalNotification
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Empty;

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.MixedReality.PowerThermalNotification.status code = Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ".";
                if (!string.IsNullOrEmpty(requestCorrelationVector))
                {
                    fullMessage += " Request CV: " + requestCorrelationVector + ".";
                }
                if (!string.IsNullOrEmpty(responseCorrelationVector))
                {
                    fullMessage += " Response CV: " + responseCorrelationVector + ".";
                }
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }
    }

    /// <summary>
    /// This interface is implemented by classes to be cached by the <see cref="ProjectedObjectCache"/>.
    /// </summary>
    internal interface ICachedObject
    {
        /// <summary>
        /// Unique cookie value for projected object identification.
        /// </summary>
        ulong Cookie { get; }
    }

    /// <summary>
    /// Represents a cache of event handlers for projected object events.
    /// </summary>
    internal static class ProjectedObjectEventHandlerCache
    {
        private readonly static IDictionary<ulong, IDictionary<string, Delegate>> tracked = new Dictionary<ulong, IDictionary<string, Delegate>>();

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Adds an event handler to the cache for the specified instance and event.
        /// The delegate is added to the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void AddEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    eventDelegates[eventName] = handler;
                    return;
                }

                eventDelegates[eventName] = Delegate.Combine(existingHandler, handler);
            }
        }

        /// <summary>
        /// Removes an event handler from the cache for the specified instance and event.
        /// The delegate is removed from the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void RemoveEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    return;
                }

                eventDelegates[eventName] = Delegate.Remove(existingHandler, handler);
            }
        }

        /// <summary>
        /// Gets the event handler for the specified instance and event name.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <returns><see cref="IReadOnlyCollection{T}"/>.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static T GetEventHandler<T>(ICachedObject instance, string eventName)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
                {
                    // No events have been cached for the object.
                    return null;
                }

                if (!events.TryGetValue(eventName, out Delegate eventDelegate))
                {
                    // The specified event has not been cached for the object.
                    return null;
                }

                return eventDelegate as T;
            }
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Clear(ICachedObject instance)
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Clear(instance.Cookie);
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Clear(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        private static IDictionary<string, Delegate> GetOrInitializeEvents(ICachedObject instance)
        {
            // We assume a lock on `tracked` is already held at this point, so no need to lock here.
            if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
            {
                // Setup event handler cache for the object.
                events = new Dictionary<string, Delegate>(StringComparer.Ordinal);
                tracked[instance.Cookie] = events;
            }

            return events;
        }
    }

    /// <summary>
    /// Represents a cache of projected object events.
    /// </summary>
    internal static class ProjectedObjectCache
    {
        private static readonly Dictionary<ulong, System.WeakReference<ICachedObject>> tracked = new Dictionary<ulong, System.WeakReference<ICachedObject>>();

        private static readonly Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCleanupNative projectedObjectCleanupHandlerDelegate = ProjectedObjectCleanupHandler;

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Initializes static members of the <see cref="ProjectedObjectCache"/> class.
        /// </summary>
        static ProjectedObjectCache()
        {
            NativeLibraryHelpers.CheckStatus(NativeLibrary.ptn_set_projected_object_cleanup(projectedObjectCleanupHandlerDelegate));
        }

        /// <summary>
        /// Adds the specified instance to the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void Add(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out WeakReference<ICachedObject> cachedReference))
                {
                    tracked[instance.Cookie] = new System.WeakReference<ICachedObject>(instance);
                    return;
                }

                // Ensure that we have a good reference.
                if (!cachedReference.TryGetTarget(out _))
                {
                    cachedReference.SetTarget(instance);
                }
            }
        }

        /// <summary>
        /// Gets a cached instance using the specified instance cookie.
        /// If a cached instance isn't found, a new instance is created using the <paramref name="createFactory"/>, which
        /// is then cached and returned.
        /// </summary>
        /// <typeparam name="T">The type of the object to get or create.</typeparam>
        /// <param name="cookie">The cookie.</param>
        /// <param name="createFactory">The create factory.</param>
        /// <returns>A cached instance of type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentException"><paramref name="cookie"/> is not valid.</exception>
        public static T GetOrCreate<T>(ulong cookie, Func<ulong, T> createFactory)
            where T : class, ICachedObject
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            ICachedObject referenceTarget;

            lock (tracked)
            {
                if (tracked.TryGetValue(cookie, out System.WeakReference<ICachedObject> reference))
                {
                    if (!reference.TryGetTarget(out referenceTarget))
                    {
                        // The reference is gone, so create a new one.
                        referenceTarget = createFactory(cookie);
                        tracked[cookie].SetTarget(referenceTarget);
                    }
                }
                else
                {
                    // Object is not being tracked. Create an instance and track it.
                    referenceTarget = createFactory(cookie);
                    tracked[cookie] = new System.WeakReference<ICachedObject>(referenceTarget);
                }
            }

            return (T)referenceTarget;
        }

        /// <summary>
        /// Removes the specified instance from the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Remove(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Remove(instance.Cookie);
        }

        /// <summary>
        /// Removes the specified instance from the cache using the instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Remove(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }
        [AOT.MonoPInvokeCallback(typeof(Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCleanupNative))]
        private static void ProjectedObjectCleanupHandler(ulong cookie)
        {
            Remove(cookie);
            ProjectedObjectEventHandlerCache.Clear(cookie);
        }
    }

    /// <summary>
    /// Any functions used for mitigation level event handling need to follow this format
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="args">
    /// The callback handle.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void PowerThermalEventHandlerNative(ulong cookie, IntPtr args);

    /// <summary>
    /// Any functions used for thermal score event handling need to follow this format
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="args">
    /// The callback handle.
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void PowerThermalScoreEventHandlerNative(ulong cookie, IntPtr args);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProjectedObjectCleanupNative(ulong cookie);

    internal static partial class NativeLibrary
    {
        internal const string DllName = "Microsoft.MixedReality.PowerThermalNotification.dll";
        [DllImport(DllName, EntryPoint="ptn_get_error_details_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPWStr)] out string result_message, [MarshalAs(UnmanagedType.LPWStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPWStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_event_args_create_power_thermal_peripheral_flags_impacted_peripherals_power_thermal_mitigation_level_mitigation_level(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags impacted_peripherals, Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel mitigation_level, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_event_args_get_impacted_peripherals(IntPtr handle, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_event_args_get_mitigation_level(IntPtr handle, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_get_for_current_process(out IntPtr result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_get_latest_peripheral_state(IntPtr handle, Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags peripheral, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_get_peripherals_of_interest(IntPtr handle, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_get_suppressed_platform_mitigation_for_peripherals(IntPtr handle, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_is_supported(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags peripheral_map, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_set_peripherals_of_interest(IntPtr handle, Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_set_power_thermal_mitigation_level_changed(IntPtr handle, ulong value, Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_set_power_thermal_thermal_score_changed(IntPtr handle, ulong value, Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_set_suppressed_platform_mitigation_for_peripherals(IntPtr handle, Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags value);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_notification_suppress_platform_mitigation(IntPtr handle, Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags flags, [MarshalAs(UnmanagedType.U1)] bool is_suppressed);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_score_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_score_args_create_power_thermal_peripheral_flags_impacted_peripherals_uint32_thermal_score(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags impacted_peripherals, uint thermal_score, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_score_args_get_impacted_peripherals(IntPtr handle, out Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_score_args_get_thermal_score(IntPtr handle, out uint result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_power_thermal_score_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.PowerThermalNotification.status ptn_set_projected_object_cleanup(Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCleanupNative callback);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    /// <summary>
    /// This is returned by SuppressedPlatformMitigationForPeripherals to indicate the latest state of a given peripheral.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct PowerThermalPeripheralStateAbi
    {
        /// <summary>
        /// Returns true if this peripheral is supported by this device for PowerThermalNotification information
        /// </summary>
        [MarshalAs(UnmanagedType.U1)]
        public bool IsSupportedPeripheral;

        /// <summary>
        /// Returns the latest MitigationLevel for the peripheral
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel MitigationLevel;

        /// <summary>
        /// Returns the latest ThermalScore for the peripheral
        /// </summary>
        public uint ThermalScore;

        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState Convert()
        {
            return Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi.Convert(this);
        }

        public static Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState Convert(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi value)
        {
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState result = new Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState();

            result.IsSupportedPeripheral = value.IsSupportedPeripheral;
            result.MitigationLevel = value.MitigationLevel;
            result.ThermalScore = value.ThermalScore;

            return result;
        }
    }

    /// <summary>
    /// This is returned by SuppressedPlatformMitigationForPeripherals to indicate the latest state of a given peripheral.
    /// </summary>
    public partial struct PowerThermalPeripheralState
    {
        /// <summary>
        /// Returns true if this peripheral is supported by this device for PowerThermalNotification information
        /// </summary>
        public bool IsSupportedPeripheral;

        /// <summary>
        /// Returns the latest MitigationLevel for the peripheral
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel MitigationLevel;

        /// <summary>
        /// Returns the latest ThermalScore for the peripheral
        /// </summary>
        public uint ThermalScore;

        internal Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi Convert()
        {
            return Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState.Convert(this);
        }

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi Convert(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState value)
        {
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi result = new Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi();

            result.IsSupportedPeripheral = value.IsSupportedPeripheral;
            result.MitigationLevel = value.MitigationLevel;
            result.ThermalScore = value.ThermalScore;

            return result;
        }
    }

    /// <summary>
    /// These are used to indicate which peripherals are being described in different operations (notifications, requests, subscriptions). They can be logically OR'd together.
    /// </summary>
    public enum PowerThermalPeripheralFlags : int
    {
        /// <summary>
        /// CPU
        /// </summary>
        Cpu = 1,
        /// <summary>
        /// GPU
        /// </summary>
        Gpu = 2,
        /// <summary>
        /// Ethernet and WiFi
        /// </summary>
        Network = 4,
        /// <summary>
        /// Display Subsystem
        /// </summary>
        Display = 8,
        /// <summary>
        /// Photo Video Camera
        /// </summary>
        PhotoVideoCamera = 16,
        /// <summary>
        /// DRAM
        /// </summary>
        Dram = 32,
        /// <summary>
        /// Battery
        /// </summary>
        Battery = 64,
    }

    /// <summary>
    /// This reflects a requested level of mitigation.  NoUserImpact means mitigations should be released whereas MaximumUserImpact means do everything you can to mitigation the situation. Keep in mind that the PowerThermalMitigationLevel applies to the PowerThermalPeripheralFlags it is presented with and means nothing by itself.
    /// </summary>
    public enum PowerThermalMitigationLevel : int
    {
        /// <summary>
        /// Any mitigations relating to the impacted peripherals should be released
        /// </summary>
        NoUserImpact = 0,
        /// <summary>
        /// Mitigations relating to the impacted peripherals that can be applied with minimal user impact should be applied
        /// </summary>
        MinimumUserImpact = 1,
        /// <summary>
        /// Mitigations relating to the impacted peripherals that can be applied with medium user impact should be applied (for example, a resolution downgrade or small loss of functionality)
        /// </summary>
        MediumUserImpact = 2,
        /// <summary>
        /// Mitigations relating to the impacted peripherals that can be applied with large user impact should be applied (for example, loss of video feature in order to keep the application running)
        /// </summary>
        MaximumUserImpact = 3,
    }

    /// <summary>
    /// Any functions used for mitigation level event handling need to follow this format
    /// </summary>
    /// <param name="sender">
    /// Sender of event
    /// </param>
    /// <param name="args">
    /// PowerThermalEventArgs for the given event
    /// </param>
    public delegate void PowerThermalEventHandler(object sender, Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs args);

    /// <summary>
    /// Any functions used for thermal score event handling need to follow this format
    /// </summary>
    /// <param name="sender">
    /// Sender of event
    /// </param>
    /// <param name="args">
    /// PowerThermalScoreArgs for the given event
    /// </param>
    public delegate void PowerThermalScoreEventHandler(object sender, Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs args);

    /// <summary>
    /// This class is used to wrap around parameters provided in a mitigation level event
    /// </summary>
    public partial class PowerThermalEventArgs : EventArgs, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected PowerThermalEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_event_args_addref(ahandle);
            Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// These are provided in notification events.  They provide information on which peripherals are being described and the PowerThermalMitigationLevel for those peripherals.
        /// </summary>
        /// <param name="impactedPeripherals">
        /// Peripherals being described by this event.
        /// </param>
        /// <param name="mitigationLevel">
        /// PowerThermalMitigationLevel describing the provided peripherals
        /// </param>
        public PowerThermalEventArgs(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags impactedPeripherals, Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel mitigationLevel)
        {
            Microsoft.MixedReality.PowerThermalNotification.status resultStatus = (Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_event_args_create_power_thermal_peripheral_flags_impacted_peripherals_power_thermal_mitigation_level_mitigation_level(impactedPeripherals, mitigationLevel, out this.handle));
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Args destructor.  Should not be called directly.
        /// </summary>
        ~PowerThermalEventArgs()
        {
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Returns the peripheral set associated with given event
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags ImpactedPeripherals
        {
            get
            {
                Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_event_args_get_impacted_peripherals(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the PowerThermalMitigationLevel associated with the given event
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel MitigationLevel
        {
            get
            {
                Microsoft.MixedReality.PowerThermalNotification.PowerThermalMitigationLevel result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_event_args_get_mitigation_level(this.handle, out result));
                return result;
            }
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs GetOrCreateInstance(ulong cookie, bool transfer)
            => Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.GetOrCreate<Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs>(
                cookie,
                _ => new Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs(ConvertCookieToHandle(cookie), transfer: transfer));

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static IntPtr ConvertCookieToHandle(ulong cookie)
            => new IntPtr((long)cookie);
    }

    /// <summary>
    /// Main class for PowerThermalNotification usage.  Use this to get an instance of the class and subscribe to notification events as well as request to suppress any platform mitigations
    /// </summary>
    public partial class PowerThermalNotification : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected PowerThermalNotification(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_addref(ahandle);
            Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.Add(this);
        }

        ~PowerThermalNotification()
        {
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// This property reflects requests from this process to suppress any platform mitigations related to the set peripherals.  Setting to zero (default) means that no actions are suppressed by this process.  Non-zero values will only take effect if the given process is running in the foreground.
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags SuppressedPlatformMitigationForPeripherals
        {
            get
            {
                Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_get_suppressed_platform_mitigation_for_peripherals(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_set_suppressed_platform_mitigation_for_peripherals(this.handle, value));
            }
        }

        /// <summary>
        /// This property contains the superset of peripherals that are to receive notification events. You must set this to a non-empty value AND PowerThermalMitigationLevelChanged in order to receive events. Events will fire when there are power-thermal changes to any of the PeripheralsOfInterest.
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags PeripheralsOfInterest
        {
            get
            {
                Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_get_peripherals_of_interest(this.handle, out result));
                return result;
            }
            set
            {
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_set_peripherals_of_interest(this.handle, value));
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(PowerThermalEventHandlerNative))]
        private static void PowerThermalMitigationLevelChangedStaticHandler(ulong cookie, IntPtr args)
        {
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification instance = GetOrCreateInstance(cookie, transfer: false);

            if (instance == null)
            {
                throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
            }

            Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventHandler handler =
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventHandler>(
                    instance,
                    nameof(PowerThermalMitigationLevelChanged));

            handler?.Invoke(instance, Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventArgs.GetOrCreateInstance(args, transfer: false));
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventHandlerNative PowerThermalMitigationLevelChangedStaticHandlerDelegate = PowerThermalMitigationLevelChangedStaticHandler;
        public event Microsoft.MixedReality.PowerThermalNotification.PowerThermalEventHandler PowerThermalMitigationLevelChanged
        {
            add
            {
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.PowerThermalMitigationLevelChanged), value);
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_set_power_thermal_mitigation_level_changed(this.handle, ((ICachedObject)this).Cookie, PowerThermalMitigationLevelChangedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.PowerThermalMitigationLevelChanged), value);
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(PowerThermalScoreEventHandlerNative))]
        private static void PowerThermalThermalScoreChangedStaticHandler(ulong cookie, IntPtr args)
        {
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification instance = GetOrCreateInstance(cookie, transfer: false);

            if (instance == null)
            {
                throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
            }

            Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreEventHandler handler =
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreEventHandler>(
                    instance,
                    nameof(PowerThermalThermalScoreChanged));

            handler?.Invoke(instance, Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs.GetOrCreateInstance(args, transfer: false));
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreEventHandlerNative PowerThermalThermalScoreChangedStaticHandlerDelegate = PowerThermalThermalScoreChangedStaticHandler;
        public event Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreEventHandler PowerThermalThermalScoreChanged
        {
            add
            {
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.PowerThermalThermalScoreChanged), value);
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_set_power_thermal_thermal_score_changed(this.handle, ((ICachedObject)this).Cookie, PowerThermalThermalScoreChangedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.PowerThermalThermalScoreChanged), value);
            }
        }

        /// <summary>
        /// This should be used to obtain an instance of the class for the current process. Each process can have a singular instance.
        /// </summary>
        public static Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification GetForCurrentProcess()
        {
            IntPtr result_handle;
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification result_object;
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_get_for_current_process(out result_handle));
            result_object = (result_handle != IntPtr.Zero) ? Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification.GetOrCreateInstance(result_handle, transfer: true) : null;
            return result_object;
        }

        /// <summary>
        /// Use this to poll the latest information for the provided peripheral. Providing more than one flag will cause this to throw an exception
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralState GetLatestPeripheralState(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags peripheral)
        {
            Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralStateAbi result;
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_get_latest_peripheral_state(this.handle, peripheral, out result));
            return result.Convert();
        }

        /// <summary>
        /// This function is another way to change the suppressed peripheral flags. Use this to set or clear a mask of peripherals to be suppressed. As is with setting the property directly, suppression only takes effect if this process is in the foreground.
        /// </summary>
        /// <param name="flags">
        /// Peripheral mask to use
        /// </param>
        /// <param name="isSuppressed">
        /// When true, flags are added to the SuppressedPlatformMitigationForPeripherals. When false, flags are cleared from the SuppressedPlatformMitigationForPeripherals.
        /// </param>
        public void SuppressPlatformMitigation(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags flags, bool isSuppressed)
        {
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_suppress_platform_mitigation(this.handle, flags, isSuppressed));
        }

        /// <summary>
        /// This function returns true if events can be registered for at least one of the provided peripherals. This means that both the system supports PowerThermalNotification events AND that it supports one of the provided peripheral bits.
        /// </summary>
        /// <param name="peripheralMap">
        /// These peripherals will be used to check for support
        /// </param>
        public static bool IsSupported(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags peripheralMap)
        {
            bool result;
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_notification_is_supported(peripheralMap, out result));
            return result;
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification GetOrCreateInstance(ulong cookie, bool transfer)
            => Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.GetOrCreate<Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification>(
                cookie,
                _ => new Microsoft.MixedReality.PowerThermalNotification.PowerThermalNotification(ConvertCookieToHandle(cookie), transfer: transfer));

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static IntPtr ConvertCookieToHandle(ulong cookie)
            => new IntPtr((long)cookie);
    }

    /// <summary>
    /// This class is used to wrap around parameters provided in a thermal score event
    /// </summary>
    public partial class PowerThermalScoreArgs : EventArgs, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected PowerThermalScoreArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_score_args_addref(ahandle);
            Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// These are provided in notification events.  They provide information on which peripherals are being described and the thermal score for those peripherals.
        /// </summary>
        /// <param name="impactedPeripherals">
        /// Peripherals being described by this event.
        /// </param>
        /// <param name="thermalScore">
        /// Thermal score describing the provided peripherals
        /// </param>
        public PowerThermalScoreArgs(Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags impactedPeripherals, uint thermalScore)
        {
            Microsoft.MixedReality.PowerThermalNotification.status resultStatus = (Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_score_args_create_power_thermal_peripheral_flags_impacted_peripherals_uint32_thermal_score(impactedPeripherals, thermalScore, out this.handle));
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Args destructor.  Should not be called directly.
        /// </summary>
        ~PowerThermalScoreArgs()
        {
            Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_score_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Returns the peripheral set associated with given event
        /// </summary>
        public Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags ImpactedPeripherals
        {
            get
            {
                Microsoft.MixedReality.PowerThermalNotification.PowerThermalPeripheralFlags result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_score_args_get_impacted_peripherals(this.handle, out result));
                return result;
            }
        }

        /// <summary>
        /// Returns the thermal score associated with the given event (100 to 0) A level of 100 is best case.  A level of 0 coincides with application termination.
        /// </summary>
        public uint ThermalScore
        {
            get
            {
                uint result;
                Microsoft.MixedReality.PowerThermalNotification.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.PowerThermalNotification.NativeLibrary.ptn_power_thermal_score_args_get_thermal_score(this.handle, out result));
                return result;
            }
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs GetOrCreateInstance(ulong cookie, bool transfer)
            => Microsoft.MixedReality.PowerThermalNotification.ProjectedObjectCache.GetOrCreate<Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs>(
                cookie,
                _ => new Microsoft.MixedReality.PowerThermalNotification.PowerThermalScoreArgs(ConvertCookieToHandle(cookie), transfer: transfer));

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static IntPtr ConvertCookieToHandle(ulong cookie)
            => new IntPtr((long)cookie);
    }

}

#endif
