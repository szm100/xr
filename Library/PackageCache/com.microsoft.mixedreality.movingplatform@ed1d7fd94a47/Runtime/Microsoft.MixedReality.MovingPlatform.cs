#if UNITY_WSA && !UNITY_EDITOR
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Microsoft.MixedReality.MovingPlatform
// This file was auto-generated from AbiDefinition.cs.
//

// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.MixedReality.MovingPlatform
{
    internal enum status
    {
        /// <summary>
        /// Success
        /// </summary>
        OK = 0,
        /// <summary>
        /// Failed
        /// </summary>
        Failed = 1,
        /// <summary>
        /// Cannot access a disposed object.
        /// </summary>
        ObjectDisposed = 2,
        /// <summary>
        /// Out of memory.
        /// </summary>
        OutOfMemory = 12,
        /// <summary>
        /// Invalid argument.
        /// </summary>
        InvalidArgument = 22,
        /// <summary>
        /// The value is out of range.
        /// </summary>
        OutOfRange = 34,
        /// <summary>
        /// Not implemented.
        /// </summary>
        NotImplemented = 38,
        /// <summary>
        /// The key does not exist in the collection.
        /// </summary>
        KeyNotFound = 77,
    }

    internal static class NativeLibraryHelpers
    {
        internal static string[] IntPtrToStringArray(IntPtr result, int result_length)
        {
            // an empty list is returned as a single null character
            if (result_length == 1)
            {
                return Array.Empty<string>();
            }

            byte[] bytes = new byte[result_length - 1];
            System.Runtime.InteropServices.Marshal.Copy(result, bytes, 0, result_length - 1);
            System.Runtime.InteropServices.Marshal.FreeCoTaskMem(result);
            return System.Text.Encoding.UTF8.GetString(bytes).Split('\0');
        }

        internal static void CheckStatus(status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string fullMessage = string.Empty;

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }

        internal static void CheckStatus(IntPtr handle, status value)
        {
            if (value == status.OK)
            {
                return;
            }

            string message;
            string requestCorrelationVector;
            string responseCorrelationVector;

            Microsoft.MixedReality.MovingPlatform.status code = Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_get_error_details(handle, out message, out requestCorrelationVector, out responseCorrelationVector);

            string fullMessage;
            if (code == status.Failed)
            {
                throw new InvalidOperationException("Unexpected error in exception handling.");
            }
            else if (code != status.OK)
            {
                fullMessage = "Exception thrown and an unexpected error in exception handling.";
            }
            else
            {
                fullMessage = message + ".";
                if (!string.IsNullOrEmpty(requestCorrelationVector))
                {
                    fullMessage += " Request CV: " + requestCorrelationVector + ".";
                }
                if (!string.IsNullOrEmpty(responseCorrelationVector))
                {
                    fullMessage += " Response CV: " + responseCorrelationVector + ".";
                }
            }

            switch (value)
            {
                case status.OK:
                    return;
                case status.Failed:
                    throw new InvalidOperationException(fullMessage);
                case status.ObjectDisposed:
                    throw new ObjectDisposedException(fullMessage);
                case status.OutOfMemory:
                    throw new OutOfMemoryException(fullMessage);
                case status.InvalidArgument:
                    throw new ArgumentException(fullMessage);
                case status.OutOfRange:
                    throw new ArgumentOutOfRangeException("", fullMessage);
                case status.NotImplemented:
                    throw new NotImplementedException(fullMessage);
                case status.KeyNotFound:
                    throw new KeyNotFoundException(fullMessage);
            }
        }
    }

    /// <summary>
    /// This interface is implemented by classes to be cached by the <see cref="ProjectedObjectCache"/>.
    /// </summary>
    internal interface ICachedObject
    {
        /// <summary>
        /// Unique cookie value for projected object identification.
        /// </summary>
        ulong Cookie { get; }
    }

    /// <summary>
    /// Represents a cache of event handlers for projected object events.
    /// </summary>
    internal static class ProjectedObjectEventHandlerCache
    {
        private readonly static IDictionary<ulong, IDictionary<string, Delegate>> tracked = new Dictionary<ulong, IDictionary<string, Delegate>>();

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Adds an event handler to the cache for the specified instance and event.
        /// The delegate is added to the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void AddEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    eventDelegates[eventName] = handler;
                    return;
                }

                eventDelegates[eventName] = Delegate.Combine(existingHandler, handler);
            }
        }

        /// <summary>
        /// Removes an event handler from the cache for the specified instance and event.
        /// The delegate is removed from the multicast delegate.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The handler.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void RemoveEventHandler<T>(ICachedObject instance, string eventName, T handler)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            lock (tracked)
            {
                IDictionary<string, Delegate> eventDelegates = GetOrInitializeEvents(instance);

                if (!eventDelegates.TryGetValue(eventName, out Delegate existingHandler) || existingHandler == null)
                {
                    return;
                }

                eventDelegates[eventName] = Delegate.Remove(existingHandler, handler);
            }
        }

        /// <summary>
        /// Gets the event handler for the specified instance and event name.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="instance">The instance.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <returns><see cref="IReadOnlyCollection{T}"/>.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static T GetEventHandler<T>(ICachedObject instance, string eventName)
            where T : Delegate
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            if (string.IsNullOrWhiteSpace(eventName))
            {
                throw new ArgumentException("The argument is either null, empty, or whitespace.", nameof(eventName));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
                {
                    // No events have been cached for the object.
                    return null;
                }

                if (!events.TryGetValue(eventName, out Delegate eventDelegate))
                {
                    // The specified event has not been cached for the object.
                    return null;
                }

                return eventDelegate as T;
            }
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Clear(ICachedObject instance)
        {
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Clear(instance.Cookie);
        }

        /// <summary>
        /// Clears the cache of event handles for the specified instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Clear(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }

        private static IDictionary<string, Delegate> GetOrInitializeEvents(ICachedObject instance)
        {
            // We assume a lock on `tracked` is already held at this point, so no need to lock here.
            if (!tracked.TryGetValue(instance.Cookie, out IDictionary<string, Delegate> events))
            {
                // Setup event handler cache for the object.
                events = new Dictionary<string, Delegate>(StringComparer.Ordinal);
                tracked[instance.Cookie] = events;
            }

            return events;
        }
    }

    /// <summary>
    /// Represents a cache of projected object events.
    /// </summary>
    internal static class ProjectedObjectCache
    {
        private static readonly Dictionary<ulong, System.WeakReference<ICachedObject>> tracked = new Dictionary<ulong, System.WeakReference<ICachedObject>>();

        private static readonly Microsoft.MixedReality.MovingPlatform.ProjectedObjectCleanupNative projectedObjectCleanupHandlerDelegate = ProjectedObjectCleanupHandler;

        /// <summary>
        /// Gets a value indicating whether the cache is empty.
        /// </summary>
        public static bool IsEmpty => tracked.Count == 0;

        /// <summary>
        /// Initializes static members of the <see cref="ProjectedObjectCache"/> class.
        /// </summary>
        static ProjectedObjectCache()
        {
            NativeLibraryHelpers.CheckStatus(NativeLibrary.mmrmp_set_projected_object_cleanup(projectedObjectCleanupHandlerDelegate));
        }

        /// <summary>
        /// Adds the specified instance to the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void Add(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            if (instance.Cookie == default)
            {
                throw new ArgumentException($"The value of {nameof(ICachedObject.Cookie)} is not valid.", nameof(instance));
            }

            lock (tracked)
            {
                if (!tracked.TryGetValue(instance.Cookie, out WeakReference<ICachedObject> cachedReference))
                {
                    tracked[instance.Cookie] = new System.WeakReference<ICachedObject>(instance);
                    return;
                }

                // Ensure that we have a good reference.
                if (!cachedReference.TryGetTarget(out _))
                {
                    cachedReference.SetTarget(instance);
                }
            }
        }

        /// <summary>
        /// Gets a cached instance using the specified instance cookie.
        /// If a cached instance isn't found, a new instance is created using the <paramref name="createFactory"/>, which
        /// is then cached and returned.
        /// </summary>
        /// <typeparam name="T">The type of the object to get or create.</typeparam>
        /// <param name="cookie">The cookie.</param>
        /// <param name="createFactory">The create factory.</param>
        /// <returns>A cached instance of type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentException"><paramref name="cookie"/> is not valid.</exception>
        public static T GetOrCreate<T>(ulong cookie, Func<ulong, T> createFactory)
            where T : class, ICachedObject
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            ICachedObject referenceTarget;

            lock (tracked)
            {
                if (tracked.TryGetValue(cookie, out System.WeakReference<ICachedObject> reference))
                {
                    if (!reference.TryGetTarget(out referenceTarget))
                    {
                        // The reference is gone, so create a new one.
                        referenceTarget = createFactory(cookie);
                        tracked[cookie].SetTarget(referenceTarget);
                    }
                }
                else
                {
                    // Object is not being tracked. Create an instance and track it.
                    referenceTarget = createFactory(cookie);
                    tracked[cookie] = new System.WeakReference<ICachedObject>(referenceTarget);
                }
            }

            return (T)referenceTarget;
        }

        /// <summary>
        /// Removes the specified instance from the cache.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public static void Remove(ICachedObject instance)
        {
            if (instance is null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            Remove(instance.Cookie);
        }

        /// <summary>
        /// Removes the specified instance from the cache using the instance cookie.
        /// </summary>
        /// <param name="cookie">The cookie.</param>
        /// <exception cref="ArgumentException"></exception>
        public static void Remove(ulong cookie)
        {
            if (cookie == default)
            {
                throw new ArgumentException($"The cookie is not valid: {cookie}.", nameof(cookie));
            }

            lock (tracked)
            {
                tracked.Remove(cookie);
            }
        }
        [AOT.MonoPInvokeCallback(typeof(Microsoft.MixedReality.MovingPlatform.ProjectedObjectCleanupNative))]
        private static void ProjectedObjectCleanupHandler(ulong cookie)
        {
            Remove(cookie);
            ProjectedObjectEventHandlerCache.Clear(cookie);
        }
    }

    /// <summary>
    /// Any functions used for Moving Platform event handling need to follow this format
    /// </summary>
    /// <param name="cookie">
    /// The callback cookie.
    /// </param>
    /// <param name="event_args">
    /// 
    /// </param>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void MovingPlatformModeChangedEventHandlerNative(ulong cookie, IntPtr event_args);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void ProjectedObjectCleanupNative(ulong cookie);

    internal static partial class NativeLibrary
    {
        internal const string DllName = "Microsoft.MixedReality.MovingPlatform.dll";
        [DllImport(DllName, EntryPoint="mmrmp_get_error_details_wide", CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_get_error_details(IntPtr handle, [MarshalAs(UnmanagedType.LPWStr)] out string result_message, [MarshalAs(UnmanagedType.LPWStr)] out string result_requestCorrelationVector, [MarshalAs(UnmanagedType.LPWStr)] out string result_responseCorrelationVector);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_event_args_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_event_args_create_moving_platform_mode_mode(Microsoft.MixedReality.MovingPlatform.MovingPlatformMode mode, out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_event_args_get_mode_entered(IntPtr handle, out Microsoft.MixedReality.MovingPlatform.MovingPlatformMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_event_args_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_addref(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_create(out IntPtr instance);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_get_mode(IntPtr handle, out Microsoft.MixedReality.MovingPlatform.MovingPlatformMode result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_is_set_mode_supported(IntPtr handle, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_release(IntPtr handle);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_set_mode_changed(IntPtr handle, ulong value, Microsoft.MixedReality.MovingPlatform.MovingPlatformModeChangedEventHandlerNative value_fn);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_moving_platform_manager_try_set_mode(IntPtr handle, Microsoft.MixedReality.MovingPlatform.MovingPlatformMode requested_mode, [MarshalAs(UnmanagedType.U1)] out bool result);
        [DllImport(DllName, CallingConvention=CallingConvention.Cdecl)]
        internal static extern Microsoft.MixedReality.MovingPlatform.status mmrmp_set_projected_object_cleanup(Microsoft.MixedReality.MovingPlatform.ProjectedObjectCleanupNative callback);
    }

    // CODE STARTS HERE

    abstract class BasePrivateDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        protected abstract int InternalGetCount();
        protected abstract TKey InternalGetKey(int index);
        protected abstract TValue InternalGetItem(TKey key);
        protected abstract void InternalSetItem(TKey key, TValue value);
        protected abstract void InternalRemoveKey(TKey key);

        public TValue this[TKey key] { get { return InternalGetItem(key); } set { InternalSetItem(key, value); } }

        public ICollection<TKey> Keys { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).ToList().AsReadOnly(); } }

        public ICollection<TValue> Values { get { return Enumerable.Range(0, InternalGetCount()).Select(n => InternalGetKey(n)).Select(k => InternalGetItem(k)).ToList().AsReadOnly(); } }

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public void Add(TKey key, TValue value)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                InternalSetItem(key, value);
                return;
            }
            throw new ArgumentException();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                TKey key = InternalGetKey(0);
                InternalRemoveKey(key);
            }
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            try
            {
                TValue value = InternalGetItem(item.Key);
                if (Comparer<TValue>.Default.Compare(value, item.Value) == 0)
                {
                    return true;
                }
                return false;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public bool ContainsKey(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }

        public bool Remove(TKey key)
        {
            try
            {
                InternalGetItem(key);
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            InternalRemoveKey(key);
            return true;
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            try
            {
                value = InternalGetItem(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                value = default(TValue);
                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < InternalGetCount(); ++i)
            {
                TKey key = InternalGetKey(i);
                yield return new KeyValuePair<TKey, TValue>(key, InternalGetItem(key));
            }
        }
    }

    abstract class BasePrivateList<T> : IList<T>
    {
        protected abstract int InternalGetCount();
        protected abstract T InternalGetItem(int index);
        protected abstract void InternalSetItem(int index, T value);
        protected abstract void InternalRemoveItem(int index);

        public int Count { get { return InternalGetCount(); } }

        public bool IsReadOnly { get { return false; } }

        public T this[int index] { get { return InternalGetItem(index); } set { InternalSetItem(index, value); } }

        public int IndexOf(T item)
        {
            int count = InternalGetCount();
            for (int i = 0; i < count; i++)
            {
                if (Comparer<T>.Default.Compare(item, InternalGetItem(i)) == 0)
                {
                    return i;
                }
            }
            return -1;
        }

        public void Insert(int index, T item)
        {
            InternalSetItem(index, item);
        }

        public void RemoveAt(int index)
        {
            InternalRemoveItem(index);
        }

        public void Add(T item)
        {
            InternalSetItem(InternalGetCount(), item);
        }

        public void Clear()
        {
            while (InternalGetCount() > 0)
            {
                InternalRemoveItem(0);
            }
        }

        public bool Contains(T item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            for (int i = 0; i < Count; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public bool Remove(T item)
        {
            int index = IndexOf(item);
            if (index < 0) return false;
            InternalRemoveItem(index);
            return true;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }
    }

    /// <summary>
    /// Defines the possible modes for the Moving Platform system. Standard makes the head tracking system use legacy algorithms, these will fail in moving platform environments. MovingPlatformOptimized uses updated algorithms that account for moving platforms.
    /// </summary>
    public enum MovingPlatformMode : int
    {
        /// <summary>
        /// The tracking mode that is set "out of the box", will not work on moving platforms.
        /// </summary>
        Standard = 0,
        /// <summary>
        /// This mode is optimized for use on moving platforms
        /// </summary>
        MovingPlatformOptimized = 1,
    }

    /// <summary>
    /// Any functions used for Moving Platform event handling need to follow this format
    /// </summary>
    /// <param name="sender">
    /// Sender of event
    /// </param>
    /// <param name="eventArgs">
    /// MovingPlatformEventArgs for the given event
    /// </param>
    public delegate void MovingPlatformModeChangedEventHandler(object sender, Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs eventArgs);

    /// <summary>
    /// Wraps the relevant information for Moving Platform Events.
    /// </summary>
    public partial class MovingPlatformEventArgs : EventArgs, ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected MovingPlatformEventArgs(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_event_args_addref(ahandle);
            Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Wraps the relevant information for Moving Platform Events.
        /// </summary>
        /// <param name="mode">
        /// Mode to initialize the class with.
        /// </param>
        public MovingPlatformEventArgs(Microsoft.MixedReality.MovingPlatform.MovingPlatformMode mode)
        {
            Microsoft.MixedReality.MovingPlatform.status resultStatus = (Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_event_args_create_moving_platform_mode_mode(mode, out this.handle));
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Destructor for MovingPlatformEventArgs.
        /// </summary>
        ~MovingPlatformEventArgs()
        {
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_event_args_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// The mode that was entered into when the event was fired. The device will be operating in this mode now.
        /// </summary>
        public Microsoft.MixedReality.MovingPlatform.MovingPlatformMode ModeEntered
        {
            get
            {
                Microsoft.MixedReality.MovingPlatform.MovingPlatformMode result;
                Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_event_args_get_mode_entered(this.handle, out result));
                return result;
            }
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        internal static Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs GetOrCreateInstance(ulong cookie, bool transfer)
            => Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.GetOrCreate<Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs>(
                cookie,
                _ => new Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs(ConvertCookieToHandle(cookie), transfer: transfer));

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static IntPtr ConvertCookieToHandle(ulong cookie)
            => new IntPtr((long)cookie);
    }

    /// <summary>
    /// Main class for Moving Platform usage.  Use this to get an instance of the class and subscribe to notification events as well as request changes to the Moving Platform system.
    /// </summary>
    public partial class MovingPlatformManager : ICachedObject
    {
        internal IntPtr handle;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected MovingPlatformManager(IntPtr ahandle, bool transfer)
        {
            this.handle = ahandle;
            if (!transfer) Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_addref(ahandle);
            Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Constructor for MovingPlatformManager.
        /// </summary>
        public MovingPlatformManager()
        {
            Microsoft.MixedReality.MovingPlatform.status resultStatus = (Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_create(out this.handle));
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, resultStatus);
            Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.Add(this);
        }

        /// <summary>
        /// Destructor for MovingPlatformManager.
        /// </summary>
        ~MovingPlatformManager()
        {
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_release(this.handle));
            this.handle = IntPtr.Zero;
        }

        /// <summary>
        /// Member variable that indicates the current mode of the system. This will return MovingPlatformMode::Standard by default if the device does not offer different head tracking modes.
        /// </summary>
        public Microsoft.MixedReality.MovingPlatform.MovingPlatformMode Mode
        {
            get
            {
                Microsoft.MixedReality.MovingPlatform.MovingPlatformMode result;
                Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_get_mode(this.handle, out result));
                return result;
            }
        }

        /// <summary>Static handler.</summary>
        [AOT.MonoPInvokeCallback(typeof(MovingPlatformModeChangedEventHandlerNative))]
        private static void ModeChangedStaticHandler(ulong cookie, IntPtr event_args)
        {
            Microsoft.MixedReality.MovingPlatform.MovingPlatformManager instance = GetOrCreateInstance(cookie, transfer: false);

            if (instance == null)
            {
                throw new System.InvalidOperationException("The object instance is not tracked by the cache.");
            }

            Microsoft.MixedReality.MovingPlatform.MovingPlatformModeChangedEventHandler handler =
                Microsoft.MixedReality.MovingPlatform.ProjectedObjectEventHandlerCache.GetEventHandler<Microsoft.MixedReality.MovingPlatform.MovingPlatformModeChangedEventHandler>(
                    instance,
                    nameof(ModeChanged));

            handler?.Invoke(instance, Microsoft.MixedReality.MovingPlatform.MovingPlatformEventArgs.GetOrCreateInstance(event_args, transfer: false));
        }
        /// <summary>This static delegate instance keeps callbacks alive.</summary>
        private static Microsoft.MixedReality.MovingPlatform.MovingPlatformModeChangedEventHandlerNative ModeChangedStaticHandlerDelegate = ModeChangedStaticHandler;
        public event Microsoft.MixedReality.MovingPlatform.MovingPlatformModeChangedEventHandler ModeChanged
        {
            add
            {
                Microsoft.MixedReality.MovingPlatform.ProjectedObjectEventHandlerCache.AddEventHandler(this, nameof(this.ModeChanged), value);
                Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_set_mode_changed(this.handle, ((ICachedObject)this).Cookie, ModeChangedStaticHandlerDelegate));
            }
            remove
            {
                Microsoft.MixedReality.MovingPlatform.ProjectedObjectEventHandlerCache.RemoveEventHandler(this, nameof(this.ModeChanged), value);
            }
        }

        /// <summary>
        /// This function returns whether it is possible to change Moving Platform Modes. It will return false if the mode change is not available or if Mobile Device Mangement (MDM) policies disallow changing the mode.
        /// </summary>
        public bool IsSetModeSupported()
        {
            bool result;
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_is_set_mode_supported(this.handle, out result));
            return result;
        }

        /// <summary>
        /// Try to set the Moving Platform mode to the requested value. If the mode is already in the requested mode, no action will be taken.
        /// </summary>
        public bool TrySetMode(Microsoft.MixedReality.MovingPlatform.MovingPlatformMode requestedMode)
        {
            bool result;
            Microsoft.MixedReality.MovingPlatform.NativeLibraryHelpers.CheckStatus(this.handle, Microsoft.MixedReality.MovingPlatform.NativeLibrary.mmrmp_moving_platform_manager_try_set_mode(this.handle, requestedMode, out result));
            return result;
        }

        ulong ICachedObject.Cookie => ConvertHandleToCookie(this.handle);

        internal static Microsoft.MixedReality.MovingPlatform.MovingPlatformManager GetOrCreateInstance(IntPtr handle, bool transfer)
            => GetOrCreateInstance(ConvertHandleToCookie(handle), transfer);

        internal static Microsoft.MixedReality.MovingPlatform.MovingPlatformManager GetOrCreateInstance(ulong cookie, bool transfer)
            => Microsoft.MixedReality.MovingPlatform.ProjectedObjectCache.GetOrCreate<Microsoft.MixedReality.MovingPlatform.MovingPlatformManager>(
                cookie,
                _ => new Microsoft.MixedReality.MovingPlatform.MovingPlatformManager(ConvertCookieToHandle(cookie), transfer: transfer));

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static ulong ConvertHandleToCookie(IntPtr handle)
        {
            if (handle == IntPtr.Zero)
            {
                throw new ArgumentException("Invalid handle.", nameof(handle));
            }

            return (ulong)handle.ToInt64();
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected static IntPtr ConvertCookieToHandle(ulong cookie)
            => new IntPtr((long)cookie);
    }

}

#endif
